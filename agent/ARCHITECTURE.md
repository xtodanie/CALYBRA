# agent/ARCHITECTURE.md

## Purpose

This document describes the Calybra system architecture at a level that is actionable for implementation, security enforcement, testing, and operational reliability.

This is not aspirational. It must match repo truth.

---

## Source of Truth Rule (Non-Negotiable)

This document MUST match:

- `firestore.rules`
- `storage.rules`
- `tests/**`
- `firebase.json` / `.firebaserc`

If conflict exists, update this document to match repo truth (or change rules/tests with proof and an ADR).

---

## System Overview

### Client

- Next.js application (App Router or Pages Router depending on repo)
- Firebase client SDK for Auth, Firestore, and Storage
- UI is strictly tenant-scoped; no cross-tenant access patterns are permitted.

Responsibilities:

- Render tenant-scoped views
- Enforce client-side allowlists and runtime validation (defense-in-depth)
- Never write server-authoritative fields

### Authenticated App Shell Contract

- Spatial ownership for authenticated routes is centralized in `src/app/[locale]/(app)/layout.tsx`.
- Layout uses a two-column grid (`sidebar + content`) with in-flow sidebar rendering.
- Page-level components must not add sidebar compensation offsets (`margin-left`, `ml-*`, `calc(100%-...)`).
- Content scrolling is inside `<main>`; shell root remains height-locked.
- Sidebar widths are sourced from a single constant module: `src/components/layout/layout-constants.ts`.
- See `agent/LAYOUT_CONTRACT.md` for enforceable UI contract details.

### Backend

- Firebase Auth for identity
- Firestore for data storage
- Firebase Storage for file objects
- Cloud Functions (if present) for server-authoritative operations:
  - user provisioning
  - ingestion pipelines (`bankTx`)
  - file verification/parsing
  - privileged transitions (finalization/verification) if required

Responsibilities:

- Create and maintain canonical user profiles (`users/{uid}`)
- Perform ingestion/normalization
- Perform privileged state transitions
- Emit audit metadata

### Environments

- Local dev uses Firebase Emulators for:
  - Auth
  - Firestore
  - Storage (if used)
  - Functions (if present and wired)
- CI uses `firebase emulators:exec` for deterministic proof runs.

---

## Multi-Tenancy Model (Non-Negotiable)

### Canonical Tenant Isolation

All tenant-owned documents must be isolated by tenant identity.

Two acceptable canonical models exist, but exactly ONE is used. The active model MUST match the current `firestore.rules` implementation.

#### Model A: Tenant Subcollections (Leaving No Doubt)

Paths are tenant-scoped:

- `tenants/{tenantId}/invoices/{invoiceId}`
- `tenants/{tenantId}/bankTx/{txId}`
- `tenants/{tenantId}/matches/{matchId}`
- `tenants/{tenantId}/monthCloses/{monthCloseId}`
- `tenants/{tenantId}/fileAssets/{assetId}`

Security implication: path-level tenancy reduces accidental joins and leakage.

#### Model B: Top-Level Collections With `tenantId` Field (Allowed but Riskier)

Paths are global, enforced by `tenantId` checks in rules:

- `invoices/{invoiceId}` with `tenantId`
- `bankTx/{txId}` with `tenantId`
- etc.

Security implication: every query and reference must preserve tenantId checks; test coverage must be stronger.

### Truth Lock Requirement

The canonical model is derived from repo truth and recorded in:

- `agent/TRUTH_SNAPSHOT.md` (generated by `node scripts/truth.mjs` and committed)

This document must state the active model accordingly.

---

## Identity and RBAC

### Canonical Identity Source

A server-authoritative `users/{uid}` document is the canonical source for:

- `tenantId`
- `role`
- account `status` (e.g., `active`/`disabled`)

Rules must use this document for tenant isolation and RBAC.

Hard rules:

- No profile => deny
- Disabled user => deny (if implemented)
- Client must not be able to modify identity primitives

### Roles

Canonical role strings MUST match rules/tests exactly and are recorded in `agent/TRUTH_SNAPSHOT.md`.

---

## Core Data Domains

### Invoices

- Payables to reconcile.
- Server-only writes (current truth), with client read access only.
- Server augments with derived data and audit metadata.

### Bank Transactions (`bankTx`)

- Bank statement line items.
- Writes are typically server-only (ingestion).
- Reads are tenant-scoped.

### Matches

- Links invoices and bankTx.
- Server-only writes (current truth), with client read access only.
- Status transitions must be explicit; cross-tenant references must be impossible.

### Month Closes

- Month-end closure workflow.
- Status machine enforced.
- Finalized month closes are immutable.

### Periods

- Period control docs for month-level status (OPEN/FINALIZED).
- Drives counterfactual timelines and readmodel generation.
- Finalized periods are immutable (server-only updates to readmodels/exports).

### Events

- Authoritative event stream for month-level recomputation.
- Read-only for clients; server-only writes.

### Read Models

- Derived projections (timeline, close friction, VAT summary, mismatches, auditor replay).
- Rebuildable and non-authoritative.

### Exports

- Deterministic ledger CSV and summary PDF artifacts.
- Generated at finalization time, read-only for clients.

### File Assets

- Metadata for uploaded artifacts (statements, invoices, supporting docs).
- Storage object path must be tenant-scoped.
- Client create is constrained; privileged statuses are server-only.

---

## Security Boundaries

### Firestore Rules (Hard Requirements)

- Default deny
- Tenant isolation for all tenant-owned docs
- RBAC enforcement for privileged operations
- Status transition enforcement for:
  - `monthCloses`
  - `matches`
  - `fileAssets`
- Finalized month closes are immutable
- Field allowlists prevent client-forged server fields

### Storage Rules (Hard Requirements)

- Default deny
- Allow writes only to tenant-scoped object paths by tenant members

Hard rule: storage paths must not allow traversal into other tenant paths.

---

## Server-Authoritative Operations

Server-only operations to prevent client forgery:

- user provisioning (create `users/{uid}` on auth create)
- bankTx ingestion and normalization
- file verification/parsing and setting verified/parsed statuses
- privileged month close finalization

Hard rule: if a field is server-authoritative, it cannot be set by clients at create or update time.

---

## Testing Architecture

### Rules Unit Tests (Required)

- Unauthenticated access denied
- Cross-tenant access denied
- RBAC enforced per role
- Status transitions enforced
- Finalization immutability enforced

### Invariant Tests (Required)

- tenant isolation enforced
- RBAC enforced per role
- status transitions enforced
- server-only writes enforced

### Emulator Execution

Rules tests must run through:

```bash
firebase emulators:exec --only firestore "npm test"
```

This ensures host/port discovery and consistent behavior.

---

## Observability and Auditability

### Minimal Audit Fields

- `createdAt`, `createdBy`
- `updatedAt`, `updatedBy`
- `statusChangedAt`, `statusChangedBy`

### Logging (Server Flows)

Server-authoritative flows must log:

- tenantId
- uid (if available)
- operation name
- result (success/failure)

Avoid logging sensitive content (raw invoices, bank payloads).

---

## Change Control (Hard Gate)

Any change to:

- canonical path model
- roles
- status values/transitions
- server vs client authority boundaries

requires:

1) ADR entry in `agent/DECISIONS.md`
2) Updates to rules/tests/contracts/schemas/seed
3) Proof commands executed and recorded (PASS)
