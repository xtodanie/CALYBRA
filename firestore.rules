rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function userDoc() {
      // Memoized for performance within a single rule evaluation
      return get(/databases/$(database)/documents/users/$(request.auth.uid));
    }
    
    function userExists() {
        return exists(userDoc().path);
    }

    function tenantOfUser() {
      return userDoc().data.tenantId;
    }

    function roleOfUser() {
      return userDoc().data.role;
    }

    function isTenantMember(tenantId) {
       return isSignedIn() && userExists() && tenantOfUser() == tenantId;
    }
    
    function hasRole(roles) {
      return isSignedIn() && userExists() && roleOfUser() in roles;
    }
    
    function isServer() {
      // In tests, this is simulated by setting the 'admin' custom claim to true.
      // In production, this would be used by a trusted server process (e.g., Cloud Functions with a service account).
      return request.auth != null && request.auth.token.admin == true;
    }
    
    // --- Global Rules ---

    // Default deny all access to prevent accidental exposure.
    match /{path=**} {
      allow read, write: if false;
    }
    
    // --- Collection-Specific Rules ---
    
    // TENANTS: Can only be read by their members. Write access is server-only.
    match /tenants/{tenantId} {
      allow read: if isTenantMember(tenantId);
      allow write: if isServer();
    }
    
    // USERS: Users can read their own document. All modifications are server-only.
    match /users/{userId} {
      allow read: if isSignedIn() && request.auth.uid == userId;
      allow write: if isServer();
    }

    // MONTH CLOSES: Granular control based on role and status.
    match /monthCloses/{monthCloseId} {
      allow read: if isSignedIn() && userExists() && resource.data.tenantId == tenantOfUser();

      allow create: if isSignedIn() && userExists() &&
                     request.resource.data.tenantId == tenantOfUser() &&
                     hasRole(["OWNER", "MANAGER", "ACCOUNTANT"]) &&
                     request.resource.data.keys().hasAll(['tenantId', 'status', 'createdAt', 'updatedAt']);

      allow update: if isSignedIn() && userExists() &&
                     resource.data.tenantId == tenantOfUser() &&
                     hasRole(["OWNER", "ACCOUNTANT"]) &&
                     request.resource.data.tenantId == resource.data.tenantId && // tenantId is immutable
                     resource.data.status != "FINALIZED"; // deny updates if finalized

      allow delete: if isServer();
    }
    
    // FILE ASSETS: Clients can create with strict constraints. Updates are server-only.
    match /fileAssets/{fileAssetId} {
      allow read: if isSignedIn() && userExists() && resource.data.tenantId == tenantOfUser();
      
      allow create: if isSignedIn() && userExists() &&
                     request.resource.data.tenantId == tenantOfUser() &&
                     hasRole(["OWNER", "MANAGER", "ACCOUNTANT"]) &&
                     // Enforce that clients can ONLY set these specific keys
                     request.resource.data.keys().hasOnly(['tenantId', 'monthCloseId', 'kind', 'filename', 'storagePath', 'sha256', 'parseStatus', 'createdAt', 'updatedAt', 'status', 'schemaVersion']) &&
                     // Enforce required initial state for new files
                     request.resource.data.parseStatus == "PENDING" &&
                     request.resource.data.status == "DRAFT";
      
      allow update, delete: if isServer();
    }
    
    // SERVER-ONLY WRITE COLLECTIONS
    // These collections can be read by tenant members but only written to by the server.
    
    match /jobs/{jobId} {
        allow read: if isSignedIn() && userExists() && resource.data.tenantId == tenantOfUser();
        allow write: if isServer();
    }
    
    match /invoices/{invoiceId} {
        allow read: if isSignedIn() && userExists() && resource.data.tenantId == tenantOfUser();
        allow write: if isServer();
    }

    match /bankTx/{txId} {
        allow read: if isSignedIn() && userExists() && resource.data.tenantId == tenantOfUser();
        allow write: if isServer();
    }
    
    match /matches/{matchId} {
        allow read: if isSignedIn() && userExists() && resource.data.tenantId == tenantOfUser();
        // For Phase 1, only the server can create/update/delete. Client is denied.
        // Finalization rule is implicitly handled; once FINALIZED, the server would need a separate path if it also needed to be blocked.
        allow write: if isServer(); 
    }

    match /exceptions/{exceptionId} {
        allow read: if isSignedIn() && userExists() && resource.data.tenantId == tenantOfUser();
        allow write: if isServer();
    }
  }
}
