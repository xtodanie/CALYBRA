rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function userPath() {
      return /databases/$(database)/documents/users/$(request.auth.uid);
    }

    function userExists() {
      return isSignedIn() && exists(userPath());
    }

    function userData() {
      // ONLY call when userExists() is true
      return get(userPath()).data;
    }

    function tenantOfUser() {
      return userData().tenantId;
    }

    function roleOfUser() {
      return userData().role;
    }

    function isTenantMember(tenantId) {
      return userExists()
        && userData().keys().hasAll(['tenantId'])
        && tenantOfUser() == tenantId;
    }

    function hasRole(roles) {
      return userExists()
        && userData().keys().hasAll(['role'])
        && roleOfUser() in roles;
    }

    function isServer() {
      // In tests, simulated by setting the 'admin' custom claim to true.
      return request.auth != null && request.auth.token.admin == true;
    }

    function requireKeys(required) {
      return request.resource != null
        && request.resource.data != null
        && request.resource.data.keys().hasAll(required);
    }

    // --- Global Rules ---

    // Default deny all access to prevent accidental exposure.
    match /{path=**} {
      allow read, write: if false;
    }

    // --- Collection-Specific Rules ---

    // TENANTS: Can only be read by their members. Write access is server-only.
    match /tenants/{tenantId} {
      allow read: if isTenantMember(tenantId);
      allow write: if isServer();
    }

    // USERS: Users can read their own document. All modifications are server-only.
    match /users/{userId} {
      allow read: if isSignedIn() && request.auth.uid == userId;
      allow write: if isServer();
    }

    // MONTH CLOSES: Granular control based on role and status.
    match /monthCloses/{monthCloseId} {
      allow read: if userExists()
        && userData().keys().hasAll(['tenantId'])
        && resource.data.keys().hasAll(['tenantId'])
        && resource.data.tenantId == tenantOfUser();

      allow create: if userExists()
        && hasRole(["OWNER", "MANAGER", "ACCOUNTANT"])
        && requireKeys(['tenantId', 'status', 'createdAt', 'updatedAt'])
        && request.resource.data.tenantId == tenantOfUser();

      // Allow server to update (needed for tests + backend workflows).
      // Clients: only OWNER/ACCOUNTANT, only if NOT FINALIZED.
      allow update: if isServer() || (
        userExists()
        && hasRole(["OWNER", "ACCOUNTANT"])
        && userData().keys().hasAll(['tenantId'])
        && resource.data.keys().hasAll(['tenantId', 'status'])
        && resource.data.tenantId == tenantOfUser()
        && resource.data.status != "FINALIZED"
      );

      allow delete: if isServer();
    }

    // FILE ASSETS: Clients can create with strict constraints. Updates are server-only.
    match /fileAssets/{fileAssetId} {
      allow read: if userExists()
        && userData().keys().hasAll(['tenantId'])
        && resource.data.keys().hasAll(['tenantId'])
        && resource.data.tenantId == tenantOfUser();

      // Clients can create files but with a very strict shape and initial state.
      allow create: if userExists()
        && hasRole(["OWNER", "MANAGER", "ACCOUNTANT"])
        && request.resource.data.keys().hasAll([
          'tenantId', 'monthCloseId', 'kind', 'filename', 'storagePath',
          'sha256', 'parseStatus', 'status', 'createdAt', 'updatedAt', 'schemaVersion'
        ])
        && request.resource.data.keys().hasOnly([
          'tenantId', 'monthCloseId', 'kind', 'filename', 'storagePath',
          'sha256', 'parseStatus', 'status', 'createdAt', 'updatedAt', 'schemaVersion'
        ])
        && request.resource.data.tenantId == tenantOfUser()
        && request.resource.data.parseStatus == "PENDING"
        && request.resource.data.status == "DRAFT";

      allow update, delete: if isServer();
    }

    // SERVER-ONLY WRITE COLLECTIONS
    // These collections can be read by tenant members but only written to by the server.

    match /jobs/{jobId} {
      allow read: if userExists()
        && userData().keys().hasAll(['tenantId'])
        && resource.data.keys().hasAll(['tenantId'])
        && resource.data.tenantId == tenantOfUser();
      allow write: if isServer();
    }

    match /invoices/{invoiceId} {
      allow read: if userExists()
        && userData().keys().hasAll(['tenantId'])
        && resource.data.keys().hasAll(['tenantId'])
        && resource.data.tenantId == tenantOfUser();
      allow write: if isServer();
    }

    match /bankTx/{txId} {
      allow read: if userExists()
        && userData().keys().hasAll(['tenantId'])
        && resource.data.keys().hasAll(['tenantId'])
        && resource.data.tenantId == tenantOfUser();
      allow write: if isServer();
    }

    match /matches/{matchId} {
      allow read: if userExists()
        && userData().keys().hasAll(['tenantId'])
        && resource.data.keys().hasAll(['tenantId'])
        && resource.data.tenantId == tenantOfUser();
      allow write: if isServer();
    }

    match /exceptions/{exceptionId} {
      allow read: if userExists()
        && userData().keys().hasAll(['tenantId'])
        && resource.data.keys().hasAll(['tenantId'])
        && resource.data.tenantId == tenantOfUser();
      allow write: if isServer();
    }
  }
}
